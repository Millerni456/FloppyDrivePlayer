package com.nicholas.floppydriveplayer;

import android.graphics.SurfaceTexture;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.opengl.GLES30;
import android.opengl.GLUtils;
import android.util.Log;
import android.view.TextureView;
import android.widget.SeekBar;

/**
 * Created by Nicholas on 9/5/2016.
 *
 * Revisions:
 * Modified by Nicholas Miller on 9/5/2017
 * 1.0 Implemented requestRender(), RENDERMODE_CONTINUOUSLY, and RENDERMODE_WHEN_DIRTY.
 * - Doing this was imperative since some application may not need to update the surface every
 *   frame.
 * - By supporting requestRender() GPU resources can be spent otherwise and less heat will be
 * - generated by applications that stay alive for long times.
 * - Callers should use setRenderMode() to change the render mode.
 * - Callers should use requestRender() to invalidate the surface.  Typically this will be done
 *   instead a child class.
 *
 * TODO:
 * - Consider implementing setELGConfigChooser()
 * - Consider implementing setEGLContextClientVersion()
 * - Consider using a state machine for clarity in the render thread.
 * - Consider wrapping TextureView and renaming to GLTextureView, then consider implementing
 *   a GLTextureView.Renderer interface to avoid abstract methods.  This would also require
 *   implementing a setRenderer() function.
 * - SurfaceTexture.release() is not properly implemented.
 *
 * Known Issues:
 * - When clicking the "Recent" button on Samsung Galaxy S7, the GLConsumer is abandoned for the
 *   surface.  This causes updateTexImage() to fail and hence rendering stops.
 *
 * References:
 * http://source.android.com/devices/graphics/index.html
 * http://source.android.com/devices/graphics/arch-sv-glsv.html
 *
 * https://github.com/ykulbashian/LiquidSurface/blob/master/liquidview/src/main/java/com/mycardboarddreams/liquidsurface/GLTextureView.java
 * https://github.com/google/grafika/blob/master/src/com/android/grafika/TextureViewGLActivity.java
 */
public abstract class GLTextureViewRenderer implements Runnable, TextureView.SurfaceTextureListener, SeekBar.OnSeekBarChangeListener {

    //Available render modes.
    public static final int RENDERMODE_CONTINUOUSLY = 1;
    public static final int RENDERMODE_WHEN_DIRTY = 0;

    private final String TAG = "GLTextureViewRenderer";

    private final Object lock = new Object();

    private Thread thread = null;
    private boolean isRunning = false;

    private SurfaceTexture surfaceTexture = null;
    private boolean checkForSurfaceTexture = true;
    private boolean surfaceChanged = false;
    private int surfaceWidth = 0, surfaceHeight = 0;

    private EGLDisplay eglDisplay = null;
    private EGLConfig eglConfig = null;
    private EGLContext eglContext = null;
    private EGLSurface eglSurface = null;

    //Default rendering mode is RENDERMODE_CONTINUOUSLY
    private int renderMode = RENDERMODE_CONTINUOUSLY;
    //This should be true so the first render takes place.
    private boolean isDirty = true;

    public abstract void onSurfaceCreated(EGLConfig config);
    public abstract void onDrawFrame();
    public abstract void onSurfaceChanged(int width, int height);
    public abstract void onSurfaceDestroyed();

    public void start() {
        isRunning = true;
        checkForSurfaceTexture = true;
        thread = new Thread(this, TAG);
        thread.start();
    }

    public void stop() {
        isRunning = false;
        thread = null;
    }

    @Override
    public void run() {
        while (isRunning) {
            if (checkForSurfaceTexture) {
                //Suspend current thread until surfaceTexture is available.
                synchronized (lock) {
                    if (surfaceTexture != null) {
                        surfaceTexture.release();
                        surfaceTexture = null;
                    }
                    while (surfaceTexture == null) {
                        try {
                            lock.wait();
                            //A spurious-wakeup could happen here, so we loop-back to ensure the
                            //condition has actually changed.  If notify is called, then it is presumed
                            //that the condition will fail.
                        } catch (InterruptedException ie) {
                            //Should never be called since this thread is not explicitly interrupted.
                            throw new RuntimeException(ie);
                        }
                    }
                }

                //At this point, there should always be a valid SurfaceTexture available.
                createEGLSurface();
                Log.i(TAG, "created EGLSurface");
            }
            else {
                onSurfaceCreated(eglConfig);

                //Enter rendering loop.
                Log.i(TAG, "entering render loop");
                while (isRunning && !checkForSurfaceTexture) {
                    synchronized (lock) {
                        if (surfaceChanged) {
                            surfaceChanged = false;
                            onSurfaceChanged(surfaceWidth, surfaceHeight);
                        }
                    }

                    //We should only call this contingent on the current render mode.
                    if (renderMode == RENDERMODE_CONTINUOUSLY)
                    {
                        onDrawFrame();

                        //Enqueue the GLES 2.0 frame to the SurfaceTexture's BufferQueue.
                        //Recall that the GLTextureViewRenderer is the producer for this buffer.
                        EGL14.eglSwapBuffers(eglDisplay, eglSurface);
                    }
                    else if(renderMode == RENDERMODE_WHEN_DIRTY)
                    {
                        //Render only when dirty in this mode.
                        //It is important to synchronize this because there is a possibility
                        //that render is requested before isDirty becomes false.
                        //If this happens, then the new frame will not be drawn.
                        synchronized(lock) {
                            if (isDirty) {
                                onDrawFrame();
                                isDirty = false;  //No longer dirty.

                                //Enqueue the GLES 2.0 frame to the SurfaceTexture's BufferQueue.
                                //Recall that the GLTextureViewRenderer is the producer for this buffer.
                                EGL14.eglSwapBuffers(eglDisplay, eglSurface);
                            }
                        }
                    }
                }

                //Allow the client code to cleanup.
                onSurfaceDestroyed();

                //Release the current EGLContext from the EGLSurface and current thread.
                EGL14.eglMakeCurrent(eglDisplay, EGL14.EGL_NO_SURFACE, EGL14.EGL_NO_SURFACE, EGL14.EGL_NO_CONTEXT);

                //Destroy Surface
                EGL14.eglDestroySurface(eglDisplay, eglSurface);

                //Destroy Context
                EGL14.eglDestroyContext(eglDisplay, eglContext);

                //Terminate the default display connection.
                EGL14.eglTerminate(eglDisplay);

                Log.i(TAG, "destroyed EGLSurface");
                //surfaceTexture.release();
            }
        }
    }

    private void createEGLSurface() {
        int error = EGL14.EGL_SUCCESS;

        //Get the default display connection.
        eglDisplay = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY);
        if (eglDisplay == EGL14.EGL_NO_DISPLAY) {
            throw new RuntimeException("eglGetDisplay failed "
                    + GLUtils.getEGLErrorString(EGL14.eglGetError()));
        }

        //Initialize default display connection.
        int[] version = new int[2];
        if  (!EGL14.eglInitialize(eglDisplay, version, 0, version, 1)) {
            throw new RuntimeException("eglInitialize failed "
                    + GLUtils.getEGLErrorString(EGL14.eglGetError()));
        }

        //Get a list of available framebuffer configurations matching the specified attributes.
        int[] configAttributes = new int[] {
                EGL14.EGL_RENDERABLE_TYPE, EGL14.EGL_OPENGL_ES2_BIT,
                EGL14.EGL_RED_SIZE, 8,
                EGL14.EGL_GREEN_SIZE, 8,
                EGL14.EGL_BLUE_SIZE, 8,
                EGL14.EGL_ALPHA_SIZE, 8,
                EGL14.EGL_DEPTH_SIZE, 16,
                EGL14.EGL_STENCIL_SIZE, 0,
                EGL14.EGL_NONE
        };
        EGLConfig[] configs = new EGLConfig[1];
        int[] configsCount = new int[1];
        eglConfig = null;
        if (!EGL14.eglChooseConfig(eglDisplay, configAttributes, 0, configs, 0, 1, configsCount, 0)) {
            throw new IllegalArgumentException ("eglChooseConfig failed"
                    + GLUtils.getEGLErrorString(EGL14.eglGetError()));
        }
        else if (configsCount[0] > 0) {
            //There is a valid configuration, use it.
            eglConfig = configs[0];
        }

        if (eglConfig == null) {
            throw new RuntimeException("eglConfig not initialized");
        }

        //Create EGL rendering context.
        int[] contextAttributes = new int[] {
                EGL14.EGL_CONTEXT_CLIENT_VERSION, 3,
                EGL14.EGL_NONE
        };
        eglContext = EGL14.eglCreateContext(eglDisplay, eglConfig, EGL14.EGL_NO_CONTEXT, contextAttributes, 0);
        if ((error = EGL14.eglGetError()) != EGL14.EGL_SUCCESS) {
            Log.e(TAG, "eglCreateContext had an error: " + GLUtils.getEGLErrorString(error) + ", " +  error);
        }

        //Create EGL Window Surface.
        int[] windowAttributes = new int[] {
                EGL14.EGL_NONE
        };
        eglSurface = EGL14.eglCreateWindowSurface(eglDisplay, eglConfig, surfaceTexture, windowAttributes, 0);
        if (eglSurface == null || eglSurface == EGL14.EGL_NO_SURFACE) {
            error = EGL14.eglGetError();
            if (error == EGL14.EGL_BAD_NATIVE_WINDOW) {
                Log.e(TAG, "eglCreateWindowSurface returned EGL14.EGL_BAD_NATIVE_WINDOW");
                return;
            }
            throw new RuntimeException("eglCreateWindowSurface failed "
                    + GLUtils.getEGLErrorString(error));
        }

        //Make the EGLContext current so that it can be used to render into the EGLSurface.
        //At this point, the viewport is set to the dimensions of the EGLSurface.
        if (!EGL14.eglMakeCurrent(eglDisplay, eglSurface, eglSurface, eglContext)) {
            throw new RuntimeException("eglMakeCurrent failed"
                    + GLUtils.getEGLErrorString(EGL14.eglGetError()));
        }

        String versionString = GLES30.glGetString(GLES30.GL_VERSION);
        Log.i(TAG, "OpenGL Version String: " + versionString);
    }

    /**
     * Invoked when a {@link TextureView}'s SurfaceTexture is ready for use.
     *
     * @param surface The surface returned by
     *                {@link TextureView#getSurfaceTexture()}
     * @param width   The width of the surface
     * @param height  The height of the surface
     */
    @Override
    public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) {
        //If the rendering thread is waiting for a SurfaceTexture, then
        //the lock is free to be taken by the UI thread.
        //This means that the waiting thread can and should be notified after
        //acquiring the SurfaceTexture.
        //If this block is entered before the rendering thread waits, then the condition will
        //fail immediately after acquiring the lock.
        synchronized (lock) {
            surfaceTexture = surface;
            checkForSurfaceTexture = false;
            surfaceChanged = true;
            surfaceWidth = width;
            surfaceHeight = height;
            lock.notify();
            Log.i(TAG, "onSurfaceTextureAvailable");
        }
    }

    /**
     * Invoked when the {@link SurfaceTexture}'s buffers size changed.
     *
     * @param surface The surface returned by
     *                {@link TextureView#getSurfaceTexture()}
     * @param width   The new width of the surface
     * @param height  The new height of the surface
     */
    @Override
    public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) {
        synchronized (lock) {
            surfaceChanged = true;
            surfaceWidth = width;
            surfaceHeight = height;
        }
        Log.i(TAG, "onSurfaceTextureSizeChanged");
    }

    /**
     * Invoked when the specified {@link SurfaceTexture} is about to be destroyed.
     * If returns true, no rendering should happen inside the surface texture after this method
     * is invoked. If returns false, the client needs to call {@link SurfaceTexture#release()}.
     * Most applications should return true.
     *
     * @param surface The surface about to be destroyed
     */
    @Override
    public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) {
        synchronized (lock) {
            surfaceTexture = null;
            checkForSurfaceTexture = true;

        }
        Log.i(TAG, "onSurfaceTextureDestroyed");
        return false;
    }

    /**
     * Invoked when the specified {@link SurfaceTexture} is updated through
     * {@link SurfaceTexture#updateTexImage()}.
     *
     * @param surface The surface just updated
     */
    @Override
    public void onSurfaceTextureUpdated(SurfaceTexture surface) {

    }

    public int getRenderMode()
    {
        return renderMode;
    }

    public void setRenderMode(int renderMode)
    {
        this.renderMode = renderMode;
    }

    public void requestRender()
    {
        synchronized(lock) {
            isDirty = true;
        }
    }
}
